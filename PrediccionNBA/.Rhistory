plot(regres01, which=4, cook.levels=cutoff)
abline(h=cutoff, lty=2, col="red")
# Added variable plots
# add id.method="identify" to interactively identify points
avPlots(regres01, ask=FALSE, id.method="identify")
# Influence Plot
influencePlot(regres01, id.method="identify", main="Influence Plot",
sub="Circle size is proportial to Cook's Distance" )
forecast::BoxCox.lambda(nba$age)
install.packages("forecast")
forecast::BoxCox.lambda(nba$age)
summary(gvmodel)
forecast::BoxCox.lambda(nba$mp)
summary(powerTransform(nba$age))
summary(powerTransform(nba$nba_draftnumber))
summary(powerTransform(nba$tm))
summary(powerTransform(nba$g))
mod <- lm(salary ~ nba_country + tm + nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, data = nba)
mod1 <- lm(salary ~ nba_country + tm, data = nba)
anova(mod1, mod)
library(MASS)
stepAIC(regres01, direction="both")
View(nba)
relweights <- function(fit,...){ R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar]) names(import) <- "Weights"
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar]) names(import) <- "Weights"
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1, drop=FALSE] dotchart(import$Weights, labels=row.names(import),
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1, drop=FALSE]
dotchart(import$Weights, labels=row.names(import),
xlab="% of R-Square", pch=19,
main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=", round(rsquare, digits=3)), ...)
return(import)
}
players <- as.data.frame(players.x77[,c("nba_draftnumber", "age", "g", "mp", "per", "threepar", "orb", "trb", "usg", "ws", "obpm")])
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1, drop=FALSE]
dotchart(import$Weights, labels=row.names(import),
xlab="% of R-Square", pch=19,
main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=", round(rsquare, digits=3)), ...)
return(import)
}
#players <- as.data.frame(players.x77[,c("nba_draftnumber", "age", "g", "mp", "per", "threepar", "orb", "trb", "usg", "ws", "obpm")])
fit <- lm(salary ~ nba_draftnumber + age + g + mp + per +
threepar + orb + trb + usg + ws + obpm, data=nba)
relweights(fit, col="blue")
library(readr)
library(dplyr)
library(ggplot2)
library(knitr)
library(gvlma)
library(MASS)
library(car)
nba <- read_csv("nba.csv")
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(ggplot2)
library(knitr)
library(gvlma)
library(MASS)
library(car)
nba <- read_csv("nba.csv")
head(nba) #primeras 10 observaciones
tail(nba) #ultimas 10 observaciones
names(nba)
class(nba) #clase de nba
typeof(nba) #tipo de dato interno usado por el objeto
str(nba)
length(nba) #cantidad de columnas
dim(nba) #cantidad de filas y columnas
summary(nba) #summary de los principales estadisticos
distinct(nba)
distinct(nba, Player)
duplicated(nba)
nrow(nba[duplicated(nba$Player), ]) #cuentame los repetidos
nba <- nba[!duplicated(nba$Player), ] #borro los duplicados y lo guardo con el mismo nombre de mi data set
distinct(nba) #compruebo los resultados
summarise_all(nba, funs(sum(is.na(.)))) #cuentame los valores nulos en el dataset
nba <- rename_with(nba, ~ tolower(gsub('%', '', .x, fixed = T)))
nba <- rename_with(nba, ~ tolower(gsub('3', 'three', .x, fixed = T)))
nba <- rename_with(nba, ~ tolower(gsub('/', '_', .x, fixed = T)))
nba <- nba[!is.na(nba$ts),]
nba <- nba[!is.na(nba$threepar),]
nba <- nba[!is.na(nba$ftr),]
nba <- nba[!is.na(nba$tov),]
nba$nba_country <- as.numeric(factor(nba$nba_country)) #paises
nba$tm <- as.numeric(factor(nba$tm)) #equipos
View(nba)
library(readr)
library(dplyr)
library(ggplot2)
library(knitr)
library(gvlma)
library(MASS)
library(car)
nba <- read_csv("nba.csv")
head(nba) #primeras 10 observaciones
tail(nba) #ultimas 10 observaciones
names(nba)
class(nba) #clase de nba
typeof(nba) #tipo de dato interno usado por el objeto
str(nba)
length(nba) #cantidad de columnas
dim(nba) #cantidad de filas y columnas
summary(nba) #summary de los principales estadisticos
distinct(nba)
distinct(nba, Player)
duplicated(nba)
nrow(nba[duplicated(nba$Player), ]) #cuentame los repetidos
nba <- nba[!duplicated(nba$Player), ] #borro los duplicados y lo guardo con el mismo nombre de mi data set
distinct(nba) #compruebo los resultados
summarise_all(nba, funs(sum(is.na(.)))) #cuentame los valores nulos en el dataset
nba <- rename_with(nba, ~ tolower(gsub('%', '', .x, fixed = T)))
nba <- rename_with(nba, ~ tolower(gsub('3', 'three', .x, fixed = T)))
nba <- rename_with(nba, ~ tolower(gsub('/', '_', .x, fixed = T)))
nba <- nba[!is.na(nba$ts),]
nba <- nba[!is.na(nba$threepar),]
nba <- nba[!is.na(nba$ftr),]
nba <- nba[!is.na(nba$tov),]
mutate(nba, country = as.numeric(factor(nba$nba_country)))
mutate(nba, team = as.numeric(factor(nba$tm)))
#nba$nba_country <- as.numeric(factor(nba$nba_country)) #paises
#nba$tm <- as.numeric(factor(nba$tm)) #equipos
View(nba)
nba <- mutate(nba, country = as.numeric(factor(nba$nba_country)))
nba <- mutate(nba, team = as.numeric(factor(nba$tm)))
#nba$nba_country <- as.numeric(factor(nba$nba_country)) #paises
#nba$tm <- as.numeric(factor(nba$tm)) #equipos
View(nba)
regres01 = lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, country, team,data = nba)
gvmodel <- gvlma(regres01)
summary(gvmodel)
#Aqui vemos que las variables explicativas mas significativa son draftnumber, age, g y mp
regres01 = lm(salary ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, country, team,data = nba)
gvmodel <- gvlma(regres01)
summary(gvmodel)
#Aqui vemos que las variables explicativas mas significativa son draftnumber, age, g y mp
regres01 = lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, country, team,data = nba)
gvmodel <- gvlma(regres01)
summary(gvmodel)
#Aqui vemos que las variables explicativas mas significativa son draftnumber, age, g y mp
mod <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, country, team,data = nba)
mod1 <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, data = nba)
anova(mod1, mod)
# vemos que las variables cualitativas country y team no son significativas para estimar el salario de los jugadores ya que al ser el valor de p muy pequeno podemos decir que se puede descartar el modelo que contenga country y tm
mod <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, country, team,data = nba)
mod1 <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, data = nba)
anova(mod1, mod)
# vemos que las variables cualitativas country y team no son significativas para estimar el salario de los jugadores ya que al ser el valor de p muy pequeno podemos decir que se puede descartar el modelo que contenga country y tm
mod <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, country, team,data = nba)
mod1 <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb + stl + blk + tov + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp, country, team, data = nba)
anova(mod1, mod)
# vemos que las variables cualitativas country y team no son significativas para estimar el salario de los jugadores ya que al ser el valor de p muy pequeno podemos decir que se puede descartar el modelo que contenga country y tm
qqPlot(regres01, labels = row.names(nba), id.method = "identify",
simulate = TRUE, main = "Q-Q Plot")
residplot <- function(fit, nbreaks=20) {
z <- rstudent(fit)
hist(z, breaks=nbreaks, freq=FALSE,
xlab="Studentized Residual",
main="Distribution of Errors")
rug(jitter(z), col="brown")
curve(dnorm(x, mean=mean(z), sd=sd(z)),
add=TRUE, col="blue", lwd=2)
lines(density(z)$x, density(z)$y,
col="red", lwd=2, lty=2)
legend("topright",
legend = c( "Normal Curve", "Kernel Density Curve"),
lty=1:2, col=c("blue","red"), cex=.7)
}
residplot(regres01)
crPlots(regres01)
crPlots(regres01)
vif(regres01)
sqrt(vif(regres01)) > 2
# tenemos problemas de multicolinealidad en ts, trb, usg, obpm, threepar, ows, dbpm, g, dws, bpm, mp, orb, blk, ws, vorp, per, drb y ws_48
outlierTest(regres01)
hat.plot <- function(fit) {
p <- length(coefficients(fit))
n <- length(fitted(fit))
plot(hatvalues(fit), main="Index Plot of Hat Values")
abline(h=c(2,3)*p/n, col="red", lty=2)
identify(1:n, hatvalues(fit), names(hatvalues(fit)))
}
hat.plot(regres01)
# Cooks Distance D
# identify D values > 4/(n-k-1)
cutoff <- 4/(nrow(nba)-length(regres01$coefficients)-2)
plot(regres01, which=4, cook.levels=cutoff)
abline(h=cutoff, lty=2, col="red")
# Added variable plots
# add id.method="identify" to interactively identify points
avPlots(regres01, ask = FALSE, id.method = "identify")
# Influence Plot
influencePlot(regres01, id.method="identify", main="Influence Plot",
sub="Circle size is proportial to Cook's Distance" )
summary(powerTransform(nba$age))
#no vale la pena transformar la variable edad para que cumpla la normalidad porque el p valor nos indica que no es necesario
summary(powerTransform(nba$nba_draftnumber))
#no vale la pena transformar la variable draftnumber para que cumpla la normalidad porque el p valor nos indica que no es necesario
summary(powerTransform(nba$g))
#no vale la pena transformar la variable g para que cumpla la normalidad porque el p valor nos indica que no es necesario
library(MASS)
stepAIC(regres01, direction = "both")
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1, drop=FALSE]
dotchart(import$Weights, labels=row.names(import),
xlab="% of R-Square", pch=19,
main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=", round(rsquare, digits=3)), ...)
return(import)
}
fit <- lm(formula = log(salary, base = 10) ~ nba_draftnumber + age +
g + mp + per + ts + threepar + ftr + orb + drb + trb + stl +
blk + tov + ows + dws + ws + ws_48 + obpm + dbpm + bpm +
vorp, data = nba, subset = country, weights = team)
relweights(fit, col="blue")
View(nba)
library(readr)
library(dplyr)
library(ggplot2)
library(knitr)
library(gvlma)
library(MASS)
library(car)
nba <- read_csv("nba.csv")
head(nba) #primeras 10 observaciones
tail(nba) #ultimas 10 observaciones
names(nba)
class(nba) #clase de nba
typeof(nba) #tipo de dato interno usado por el objeto
str(nba)
length(nba) #cantidad de columnas
dim(nba) #cantidad de filas y columnas
summary(nba) #summary de los principales estadisticos
distinct(nba)
distinct(nba, Player)
duplicated(nba)
nrow(nba[duplicated(nba$Player), ]) #cuentame los repetidos
nba <- nba[!duplicated(nba$Player), ] #borro los duplicados y lo guardo con el mismo nombre de mi data set
distinct(nba) #compruebo los resultados
summarise_all(nba, funs(sum(is.na(.)))) #cuentame los valores nulos en el dataset
nba <- rename_with(nba, ~ tolower(gsub('%', '', .x, fixed = T)))
nba <- rename_with(nba, ~ tolower(gsub('3', 'three', .x, fixed = T)))
nba <- rename_with(nba, ~ tolower(gsub('/', '_', .x, fixed = T)))
nba <- nba[!is.na(nba$ts),]
nba <- nba[!is.na(nba$threepar),]
nba <- nba[!is.na(nba$ftr),]
nba <- nba[!is.na(nba$tov),]
nba <- mutate(nba, country = as.numeric(factor(nba$nba_country))) #paises
nba <- mutate(nba, team = as.numeric(factor(nba$tm))) #teams
View(nba)
regres01 = lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp + country + team,data = nba)
gvmodel <- gvlma(regres01)
summary(gvmodel)
#Aqui vemos que las variables explicativas mas significativa son draftnumber, age, g y mp
qqPlot(regres01, labels = row.names(nba), id.method = "identify",
simulate = TRUE, main = "Q-Q Plot")
residplot <- function(fit, nbreaks=20) {
z <- rstudent(fit)
hist(z, breaks=nbreaks, freq=FALSE,
xlab="Studentized Residual",
main="Distribution of Errors")
rug(jitter(z), col="brown")
curve(dnorm(x, mean=mean(z), sd=sd(z)),
add=TRUE, col="blue", lwd=2)
lines(density(z)$x, density(z)$y,
col="red", lwd=2, lty=2)
legend("topright",
legend = c( "Normal Curve", "Kernel Density Curve"),
lty=1:2, col=c("blue","red"), cex=.7)
}
residplot(regres01)
crPlots(regres01)
vif(regres01)
sqrt(vif(regres01)) > 2
# tenemos problemas de multicolinealidad en en todas las variables menos en draft number
outlierTest(regres01)
hat.plot <- function(fit) {
p <- length(coefficients(fit))
n <- length(fitted(fit))
plot(hatvalues(fit), main="Index Plot of Hat Values")
abline(h=c(2,3)*p/n, col="red", lty=2)
identify(1:n, hatvalues(fit), names(hatvalues(fit)))
}
hat.plot(regres01)
# Cooks Distance D
# identify D values > 4/(n-k-1)
cutoff <- 4/(nrow(nba)-length(regres01$coefficients)-2)
plot(regres01, which=4, cook.levels=cutoff)
abline(h=cutoff, lty=2, col="red")
# Added variable plots
# add id.method="identify" to interactively identify points
avPlots(regres01, ask = FALSE, id.method = "identify")
# Influence Plot
influencePlot(regres01, id.method="identify", main="Influence Plot",
sub="Circle size is proportial to Cook's Distance" )
summary(powerTransform(nba$age))
#no vale la pena transformar la variable edad para que cumpla la normalidad porque el p valor nos indica que no es necesario
summary(powerTransform(nba$nba_draftnumber))
#no vale la pena transformar la variable draftnumber para que cumpla la normalidad porque el p valor nos indica que no es necesario
summary(powerTransform(nba$g))
#no vale la pena transformar la variable g para que cumpla la normalidad porque el p valor nos indica que no es necesario
library(MASS)
stepAIC(regres01, direction = "both")
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1, drop=FALSE]
dotchart(import$Weights, labels=row.names(import),
xlab="% of R-Square", pch=19,
main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=", round(rsquare, digits=3)), ...)
return(import)
}
fit <- lm(formula = log(salary, base = 10) ~ nba_draftnumber + age +
mp + per + ts + trb + ast + tov + usg + dws + ws_48 + obpm +
bpm, data = nba, subset = country, weights = team)
relweights(fit, col="blue")
summary(lm(formula = log(salary, base = 10) ~ nba_draftnumber + age +
mp + per + ts + trb + ast + tov + usg + dws + ws_48 + obpm +
bpm, data = nba))
library(bootstrap)
install.packages("bootstrap")
library(bootstrap)
shrinkage <- function(fit, k=10){ require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)] y <- fit$model[,1]
library(bootstrap)
shrinkage <- function(fit, k=10){ require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x, y, theta.fit, theta.predict, ngroup=k)
r2 <- cor(y, fit$fitted.values)^2
r2cv <- cor(y, results$cv.fit)^2
cat("Original R-square =", r2, "\n")
cat(k, "Fold Cross-Validated R-square =", r2cv, "\n")
cat("Change =", r2-r2cv, "\n")
}
states <- as.data.frame(lm(formula = log(salary, base = 10) ~ nba_draftnumber + age +
mp + per + ts + trb + ast + tov + usg + dws + ws_48 + obpm +
bpm, data = nba))
library(bootstrap)
shrinkage <- function(fit, k=10){ require(bootstrap)
theta.fit <- function(x,y){lsfit(x,y)}
theta.predict <- function(fit,x){cbind(1,x)%*%fit$coef}
x <- fit$model[,2:ncol(fit$model)]
y <- fit$model[,1]
results <- crossval(x, y, theta.fit, theta.predict, ngroup=k)
r2 <- cor(y, fit$fitted.values)^2
r2cv <- cor(y, results$cv.fit)^2
cat("Original R-square =", r2, "\n")
cat(k, "Fold Cross-Validated R-square =", r2cv, "\n")
cat("Change =", r2-r2cv, "\n")
}
states <- as.data.frame(nba)
fit <- lm(formula = log(salary, base = 10) ~ nba_draftnumber + age +
mp + per + ts + trb + ast + tov + usg + dws + ws_48 + obpm +
bpm, data=states)
shrinkage(fit)
relweights <- function(fit,...){
R <- cor(fit$model)
nvar <- ncol(R)
rxx <- R[2:nvar, 2:nvar]
rxy <- R[2:nvar, 1]
svd <- eigen(rxx)
evec <- svd$vectors
ev <- svd$values
delta <- diag(sqrt(ev))
lambda <- evec %*% delta %*% t(evec)
lambdasq <- lambda ^ 2
beta <- solve(lambda) %*% rxy
rsquare <- colSums(beta ^ 2)
rawwgt <- lambdasq %*% beta ^ 2
import <- (rawwgt / rsquare) * 100
import <- as.data.frame(import)
row.names(import) <- names(fit$model[2:nvar])
names(import) <- "Weights"
import <- import[order(import),1, drop=FALSE]
dotchart(import$Weights, labels=row.names(import),
xlab="% of R-Square", pch=19,
main="Relative Importance of Predictor Variables",
sub=paste("Total R-Square=", round(rsquare, digits=3)), ...)
return(import)
}
fit <- lm(formula = log(salary, base = 10) ~ nba_draftnumber + age +
mp + per + ts + trb + ast + tov + usg + dws + ws_48 + obpm +
bpm, data = nba)
relweights(fit, col="blue")
mod <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp + country + team,data = nba)
mod1 <- lm(log(salary, base = 10) ~ nba_draftnumber + age + g + mp + per + ts + threepar + ftr + orb + drb + trb  + ast + stl + blk + tov + usg + ows + dws + ws + ws_48 + obpm + dbpm + bpm + vorp,data = nba)
anova(mod1, mod)
# vemos que las variables cualitativas ast y usg son significativas para estimar el salario de los jugadores ya que al ser el valor de p alto podemos decir que no se pueden descartar el modelo que contenga estas variables
